// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: container.proto

#ifndef PROTOBUF_container_2eproto__INCLUDED
#define PROTOBUF_container_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_container_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsContainerImpl();
void InitDefaultsContainer();
void InitDefaultsContainersImpl();
void InitDefaultsContainers();
void InitDefaultsItemImpl();
void InitDefaultsItem();
void InitDefaultsItemsImpl();
void InitDefaultsItems();
void InitDefaultsItemsOfContainerImpl();
void InitDefaultsItemsOfContainer();
void InitDefaultsDeleteItemsRequestImpl();
void InitDefaultsDeleteItemsRequest();
void InitDefaultsBackupImpl();
void InitDefaultsBackup();
void InitDefaultsFuncImpl();
void InitDefaultsFunc();
void InitDefaultsFuncResultImpl();
void InitDefaultsFuncResult();
inline void InitDefaults() {
  InitDefaultsContainer();
  InitDefaultsContainers();
  InitDefaultsItem();
  InitDefaultsItems();
  InitDefaultsItemsOfContainer();
  InitDefaultsDeleteItemsRequest();
  InitDefaultsBackup();
  InitDefaultsFunc();
  InitDefaultsFuncResult();
}
}  // namespace protobuf_container_2eproto
namespace container {
class Backup;
class BackupDefaultTypeInternal;
extern BackupDefaultTypeInternal _Backup_default_instance_;
class Container;
class ContainerDefaultTypeInternal;
extern ContainerDefaultTypeInternal _Container_default_instance_;
class Containers;
class ContainersDefaultTypeInternal;
extern ContainersDefaultTypeInternal _Containers_default_instance_;
class DeleteItemsRequest;
class DeleteItemsRequestDefaultTypeInternal;
extern DeleteItemsRequestDefaultTypeInternal _DeleteItemsRequest_default_instance_;
class Func;
class FuncDefaultTypeInternal;
extern FuncDefaultTypeInternal _Func_default_instance_;
class FuncResult;
class FuncResultDefaultTypeInternal;
extern FuncResultDefaultTypeInternal _FuncResult_default_instance_;
class Item;
class ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class Items;
class ItemsDefaultTypeInternal;
extern ItemsDefaultTypeInternal _Items_default_instance_;
class ItemsOfContainer;
class ItemsOfContainerDefaultTypeInternal;
extern ItemsOfContainerDefaultTypeInternal _ItemsOfContainer_default_instance_;
}  // namespace container
namespace container {

enum FuncType {
  Sum = 0,
  Count = 1,
  FuncType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FuncType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FuncType_IsValid(int value);
const FuncType FuncType_MIN = Sum;
const FuncType FuncType_MAX = Count;
const int FuncType_ARRAYSIZE = FuncType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FuncType_descriptor();
inline const ::std::string& FuncType_Name(FuncType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FuncType_descriptor(), value);
}
inline bool FuncType_Parse(
    const ::std::string& name, FuncType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FuncType>(
    FuncType_descriptor(), name, value);
}
// ===================================================================

class Container : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:container.Container) */ {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Container(Container&& from) noexcept
    : Container() {
    *this = ::std::move(from);
  }

  inline Container& operator=(Container&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Container* internal_default_instance() {
    return reinterpret_cast<const Container*>(
               &_Container_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Container* other);
  friend void swap(Container& a, Container& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Container* New() const PROTOBUF_FINAL { return New(NULL); }

  Container* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Container* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .common.UniqueId icon_id = 3;
  bool has_icon_id() const;
  void clear_icon_id();
  static const int kIconIdFieldNumber = 3;
  const ::common::UniqueId& icon_id() const;
  ::common::UniqueId* release_icon_id();
  ::common::UniqueId* mutable_icon_id();
  void set_allocated_icon_id(::common::UniqueId* icon_id);

  // bool is_public = 2;
  void clear_is_public();
  static const int kIsPublicFieldNumber = 2;
  bool is_public() const;
  void set_is_public(bool value);

  // @@protoc_insertion_point(class_scope:container.Container)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::common::UniqueId* icon_id_;
  bool is_public_;
  mutable int _cached_size_;
  friend struct ::protobuf_container_2eproto::TableStruct;
  friend void ::protobuf_container_2eproto::InitDefaultsContainerImpl();
};
// -------------------------------------------------------------------

class Containers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:container.Containers) */ {
 public:
  Containers();
  virtual ~Containers();

  Containers(const Containers& from);

  inline Containers& operator=(const Containers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Containers(Containers&& from) noexcept
    : Containers() {
    *this = ::std::move(from);
  }

  inline Containers& operator=(Containers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Containers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Containers* internal_default_instance() {
    return reinterpret_cast<const Containers*>(
               &_Containers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Containers* other);
  friend void swap(Containers& a, Containers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Containers* New() const PROTOBUF_FINAL { return New(NULL); }

  Containers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Containers& from);
  void MergeFrom(const Containers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Containers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .container.Container containers = 1;
  int containers_size() const;
  void clear_containers();
  static const int kContainersFieldNumber = 1;
  const ::container::Container& containers(int index) const;
  ::container::Container* mutable_containers(int index);
  ::container::Container* add_containers();
  ::google::protobuf::RepeatedPtrField< ::container::Container >*
      mutable_containers();
  const ::google::protobuf::RepeatedPtrField< ::container::Container >&
      containers() const;

  // @@protoc_insertion_point(class_scope:container.Containers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::container::Container > containers_;
  mutable int _cached_size_;
  friend struct ::protobuf_container_2eproto::TableStruct;
  friend void ::protobuf_container_2eproto::InitDefaultsContainersImpl();
};
// -------------------------------------------------------------------

class Item : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:container.Item) */ {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Item* other);
  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 2;
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // bytes blob = 3;
  void clear_blob();
  static const int kBlobFieldNumber = 3;
  const ::std::string& blob() const;
  void set_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_blob(::std::string&& value);
  #endif
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  ::std::string* mutable_blob();
  ::std::string* release_blob();
  void set_allocated_blob(::std::string* blob);

  // .common.UniqueId id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::common::UniqueId& id() const;
  ::common::UniqueId* release_id();
  ::common::UniqueId* mutable_id();
  void set_allocated_id(::common::UniqueId* id);

  // @@protoc_insertion_point(class_scope:container.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr blob_;
  ::common::UniqueId* id_;
  mutable int _cached_size_;
  friend struct ::protobuf_container_2eproto::TableStruct;
  friend void ::protobuf_container_2eproto::InitDefaultsItemImpl();
};
// -------------------------------------------------------------------

class Items : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:container.Items) */ {
 public:
  Items();
  virtual ~Items();

  Items(const Items& from);

  inline Items& operator=(const Items& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Items(Items&& from) noexcept
    : Items() {
    *this = ::std::move(from);
  }

  inline Items& operator=(Items&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Items& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Items* internal_default_instance() {
    return reinterpret_cast<const Items*>(
               &_Items_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Items* other);
  friend void swap(Items& a, Items& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Items* New() const PROTOBUF_FINAL { return New(NULL); }

  Items* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Items& from);
  void MergeFrom(const Items& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Items* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .container.Item items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::container::Item& items(int index) const;
  ::container::Item* mutable_items(int index);
  ::container::Item* add_items();
  ::google::protobuf::RepeatedPtrField< ::container::Item >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::container::Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:container.Items)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::container::Item > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_container_2eproto::TableStruct;
  friend void ::protobuf_container_2eproto::InitDefaultsItemsImpl();
};
// -------------------------------------------------------------------

class ItemsOfContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:container.ItemsOfContainer) */ {
 public:
  ItemsOfContainer();
  virtual ~ItemsOfContainer();

  ItemsOfContainer(const ItemsOfContainer& from);

  inline ItemsOfContainer& operator=(const ItemsOfContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemsOfContainer(ItemsOfContainer&& from) noexcept
    : ItemsOfContainer() {
    *this = ::std::move(from);
  }

  inline ItemsOfContainer& operator=(ItemsOfContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemsOfContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemsOfContainer* internal_default_instance() {
    return reinterpret_cast<const ItemsOfContainer*>(
               &_ItemsOfContainer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ItemsOfContainer* other);
  friend void swap(ItemsOfContainer& a, ItemsOfContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemsOfContainer* New() const PROTOBUF_FINAL { return New(NULL); }

  ItemsOfContainer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ItemsOfContainer& from);
  void MergeFrom(const ItemsOfContainer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ItemsOfContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_name = 1;
  void clear_container_name();
  static const int kContainerNameFieldNumber = 1;
  const ::std::string& container_name() const;
  void set_container_name(const ::std::string& value);
  #if LANG_CXX11
  void set_container_name(::std::string&& value);
  #endif
  void set_container_name(const char* value);
  void set_container_name(const char* value, size_t size);
  ::std::string* mutable_container_name();
  ::std::string* release_container_name();
  void set_allocated_container_name(::std::string* container_name);

  // .container.Items items = 2;
  bool has_items() const;
  void clear_items();
  static const int kItemsFieldNumber = 2;
  const ::container::Items& items() const;
  ::container::Items* release_items();
  ::container::Items* mutable_items();
  void set_allocated_items(::container::Items* items);

  // @@protoc_insertion_point(class_scope:container.ItemsOfContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_name_;
  ::container::Items* items_;
  mutable int _cached_size_;
  friend struct ::protobuf_container_2eproto::TableStruct;
  friend void ::protobuf_container_2eproto::InitDefaultsItemsOfContainerImpl();
};
// -------------------------------------------------------------------

class DeleteItemsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:container.DeleteItemsRequest) */ {
 public:
  DeleteItemsRequest();
  virtual ~DeleteItemsRequest();

  DeleteItemsRequest(const DeleteItemsRequest& from);

  inline DeleteItemsRequest& operator=(const DeleteItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteItemsRequest(DeleteItemsRequest&& from) noexcept
    : DeleteItemsRequest() {
    *this = ::std::move(from);
  }

  inline DeleteItemsRequest& operator=(DeleteItemsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteItemsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteItemsRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteItemsRequest*>(
               &_DeleteItemsRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DeleteItemsRequest* other);
  friend void swap(DeleteItemsRequest& a, DeleteItemsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteItemsRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteItemsRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteItemsRequest& from);
  void MergeFrom(const DeleteItemsRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteItemsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_name = 1;
  void clear_container_name();
  static const int kContainerNameFieldNumber = 1;
  const ::std::string& container_name() const;
  void set_container_name(const ::std::string& value);
  #if LANG_CXX11
  void set_container_name(::std::string&& value);
  #endif
  void set_container_name(const char* value);
  void set_container_name(const char* value, size_t size);
  ::std::string* mutable_container_name();
  ::std::string* release_container_name();
  void set_allocated_container_name(::std::string* container_name);

  // .common.IdSet id_set = 2;
  bool has_id_set() const;
  void clear_id_set();
  static const int kIdSetFieldNumber = 2;
  const ::common::IdSet& id_set() const;
  ::common::IdSet* release_id_set();
  ::common::IdSet* mutable_id_set();
  void set_allocated_id_set(::common::IdSet* id_set);

  // @@protoc_insertion_point(class_scope:container.DeleteItemsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_name_;
  ::common::IdSet* id_set_;
  mutable int _cached_size_;
  friend struct ::protobuf_container_2eproto::TableStruct;
  friend void ::protobuf_container_2eproto::InitDefaultsDeleteItemsRequestImpl();
};
// -------------------------------------------------------------------

class Backup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:container.Backup) */ {
 public:
  Backup();
  virtual ~Backup();

  Backup(const Backup& from);

  inline Backup& operator=(const Backup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Backup(Backup&& from) noexcept
    : Backup() {
    *this = ::std::move(from);
  }

  inline Backup& operator=(Backup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Backup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Backup* internal_default_instance() {
    return reinterpret_cast<const Backup*>(
               &_Backup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Backup* other);
  friend void swap(Backup& a, Backup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Backup* New() const PROTOBUF_FINAL { return New(NULL); }

  Backup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Backup& from);
  void MergeFrom(const Backup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Backup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes blob = 1;
  void clear_blob();
  static const int kBlobFieldNumber = 1;
  const ::std::string& blob() const;
  void set_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_blob(::std::string&& value);
  #endif
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  ::std::string* mutable_blob();
  ::std::string* release_blob();
  void set_allocated_blob(::std::string* blob);

  // @@protoc_insertion_point(class_scope:container.Backup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr blob_;
  mutable int _cached_size_;
  friend struct ::protobuf_container_2eproto::TableStruct;
  friend void ::protobuf_container_2eproto::InitDefaultsBackupImpl();
};
// -------------------------------------------------------------------

class Func : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:container.Func) */ {
 public:
  Func();
  virtual ~Func();

  Func(const Func& from);

  inline Func& operator=(const Func& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Func(Func&& from) noexcept
    : Func() {
    *this = ::std::move(from);
  }

  inline Func& operator=(Func&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Func& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Func* internal_default_instance() {
    return reinterpret_cast<const Func*>(
               &_Func_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Func* other);
  friend void swap(Func& a, Func& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Func* New() const PROTOBUF_FINAL { return New(NULL); }

  Func* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Func& from);
  void MergeFrom(const Func& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Func* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_name = 2;
  void clear_container_name();
  static const int kContainerNameFieldNumber = 2;
  const ::std::string& container_name() const;
  void set_container_name(const ::std::string& value);
  #if LANG_CXX11
  void set_container_name(::std::string&& value);
  #endif
  void set_container_name(const char* value);
  void set_container_name(const char* value, size_t size);
  ::std::string* mutable_container_name();
  ::std::string* release_container_name();
  void set_allocated_container_name(::std::string* container_name);

  // .container.FuncType func_type = 1;
  void clear_func_type();
  static const int kFuncTypeFieldNumber = 1;
  ::container::FuncType func_type() const;
  void set_func_type(::container::FuncType value);

  // @@protoc_insertion_point(class_scope:container.Func)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_name_;
  int func_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_container_2eproto::TableStruct;
  friend void ::protobuf_container_2eproto::InitDefaultsFuncImpl();
};
// -------------------------------------------------------------------

class FuncResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:container.FuncResult) */ {
 public:
  FuncResult();
  virtual ~FuncResult();

  FuncResult(const FuncResult& from);

  inline FuncResult& operator=(const FuncResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FuncResult(FuncResult&& from) noexcept
    : FuncResult() {
    *this = ::std::move(from);
  }

  inline FuncResult& operator=(FuncResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FuncResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FuncResult* internal_default_instance() {
    return reinterpret_cast<const FuncResult*>(
               &_FuncResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(FuncResult* other);
  friend void swap(FuncResult& a, FuncResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FuncResult* New() const PROTOBUF_FINAL { return New(NULL); }

  FuncResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FuncResult& from);
  void MergeFrom(const FuncResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FuncResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.OperationResultMessage op_result = 1;
  bool has_op_result() const;
  void clear_op_result();
  static const int kOpResultFieldNumber = 1;
  const ::common::OperationResultMessage& op_result() const;
  ::common::OperationResultMessage* release_op_result();
  ::common::OperationResultMessage* mutable_op_result();
  void set_allocated_op_result(::common::OperationResultMessage* op_result);

  // double value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:container.FuncResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::OperationResultMessage* op_result_;
  double value_;
  mutable int _cached_size_;
  friend struct ::protobuf_container_2eproto::TableStruct;
  friend void ::protobuf_container_2eproto::InitDefaultsFuncResultImpl();
};
// ===================================================================

class ContainerService_Stub;

class ContainerService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ContainerService() {};
 public:
  virtual ~ContainerService();

  typedef ContainerService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void AddContainer(::google::protobuf::RpcController* controller,
                       const ::container::Container* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void GetPublicContainers(::google::protobuf::RpcController* controller,
                       const ::common::EmptyMessage* request,
                       ::container::Containers* response,
                       ::google::protobuf::Closure* done);
  virtual void ClearContainer(::google::protobuf::RpcController* controller,
                       const ::common::StringMessage* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void DeleteContainer(::google::protobuf::RpcController* controller,
                       const ::common::StringMessage* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void ExecFunc(::google::protobuf::RpcController* controller,
                       const ::container::Func* request,
                       ::container::FuncResult* response,
                       ::google::protobuf::Closure* done);
  virtual void GetItems(::google::protobuf::RpcController* controller,
                       const ::common::StringMessage* request,
                       ::container::Items* response,
                       ::google::protobuf::Closure* done);
  virtual void InsertItems(::google::protobuf::RpcController* controller,
                       const ::container::ItemsOfContainer* request,
                       ::common::IdSet* response,
                       ::google::protobuf::Closure* done);
  virtual void ReplaceItems(::google::protobuf::RpcController* controller,
                       const ::container::ItemsOfContainer* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void DeleteItems(::google::protobuf::RpcController* controller,
                       const ::container::DeleteItemsRequest* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void Fetch(::google::protobuf::RpcController* controller,
                       const ::common::EmptyMessage* request,
                       ::container::Backup* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ContainerService);
};

class ContainerService_Stub : public ContainerService {
 public:
  ContainerService_Stub(::google::protobuf::RpcChannel* channel);
  ContainerService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~ContainerService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements ContainerService ------------------------------------------

  void AddContainer(::google::protobuf::RpcController* controller,
                       const ::container::Container* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  void GetPublicContainers(::google::protobuf::RpcController* controller,
                       const ::common::EmptyMessage* request,
                       ::container::Containers* response,
                       ::google::protobuf::Closure* done);
  void ClearContainer(::google::protobuf::RpcController* controller,
                       const ::common::StringMessage* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  void DeleteContainer(::google::protobuf::RpcController* controller,
                       const ::common::StringMessage* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  void ExecFunc(::google::protobuf::RpcController* controller,
                       const ::container::Func* request,
                       ::container::FuncResult* response,
                       ::google::protobuf::Closure* done);
  void GetItems(::google::protobuf::RpcController* controller,
                       const ::common::StringMessage* request,
                       ::container::Items* response,
                       ::google::protobuf::Closure* done);
  void InsertItems(::google::protobuf::RpcController* controller,
                       const ::container::ItemsOfContainer* request,
                       ::common::IdSet* response,
                       ::google::protobuf::Closure* done);
  void ReplaceItems(::google::protobuf::RpcController* controller,
                       const ::container::ItemsOfContainer* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  void DeleteItems(::google::protobuf::RpcController* controller,
                       const ::container::DeleteItemsRequest* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  void Fetch(::google::protobuf::RpcController* controller,
                       const ::common::EmptyMessage* request,
                       ::container::Backup* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ContainerService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Container

// string name = 1;
inline void Container::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::name() const {
  // @@protoc_insertion_point(field_get:container.Container.name)
  return name_.GetNoArena();
}
inline void Container::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:container.Container.name)
}
#if LANG_CXX11
inline void Container::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:container.Container.name)
}
#endif
inline void Container::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:container.Container.name)
}
inline void Container::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:container.Container.name)
}
inline ::std::string* Container::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:container.Container.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_name() {
  // @@protoc_insertion_point(field_release:container.Container.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:container.Container.name)
}

// bool is_public = 2;
inline void Container::clear_is_public() {
  is_public_ = false;
}
inline bool Container::is_public() const {
  // @@protoc_insertion_point(field_get:container.Container.is_public)
  return is_public_;
}
inline void Container::set_is_public(bool value) {
  
  is_public_ = value;
  // @@protoc_insertion_point(field_set:container.Container.is_public)
}

// .common.UniqueId icon_id = 3;
inline bool Container::has_icon_id() const {
  return this != internal_default_instance() && icon_id_ != NULL;
}
inline const ::common::UniqueId& Container::icon_id() const {
  const ::common::UniqueId* p = icon_id_;
  // @@protoc_insertion_point(field_get:container.Container.icon_id)
  return p != NULL ? *p : *reinterpret_cast<const ::common::UniqueId*>(
      &::common::_UniqueId_default_instance_);
}
inline ::common::UniqueId* Container::release_icon_id() {
  // @@protoc_insertion_point(field_release:container.Container.icon_id)
  
  ::common::UniqueId* temp = icon_id_;
  icon_id_ = NULL;
  return temp;
}
inline ::common::UniqueId* Container::mutable_icon_id() {
  
  if (icon_id_ == NULL) {
    icon_id_ = new ::common::UniqueId;
  }
  // @@protoc_insertion_point(field_mutable:container.Container.icon_id)
  return icon_id_;
}
inline void Container::set_allocated_icon_id(::common::UniqueId* icon_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(icon_id_);
  }
  if (icon_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      icon_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, icon_id, submessage_arena);
    }
    
  } else {
    
  }
  icon_id_ = icon_id;
  // @@protoc_insertion_point(field_set_allocated:container.Container.icon_id)
}

// -------------------------------------------------------------------

// Containers

// repeated .container.Container containers = 1;
inline int Containers::containers_size() const {
  return containers_.size();
}
inline void Containers::clear_containers() {
  containers_.Clear();
}
inline const ::container::Container& Containers::containers(int index) const {
  // @@protoc_insertion_point(field_get:container.Containers.containers)
  return containers_.Get(index);
}
inline ::container::Container* Containers::mutable_containers(int index) {
  // @@protoc_insertion_point(field_mutable:container.Containers.containers)
  return containers_.Mutable(index);
}
inline ::container::Container* Containers::add_containers() {
  // @@protoc_insertion_point(field_add:container.Containers.containers)
  return containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::container::Container >*
Containers::mutable_containers() {
  // @@protoc_insertion_point(field_mutable_list:container.Containers.containers)
  return &containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::container::Container >&
Containers::containers() const {
  // @@protoc_insertion_point(field_list:container.Containers.containers)
  return containers_;
}

// -------------------------------------------------------------------

// Item

// .common.UniqueId id = 1;
inline bool Item::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline const ::common::UniqueId& Item::id() const {
  const ::common::UniqueId* p = id_;
  // @@protoc_insertion_point(field_get:container.Item.id)
  return p != NULL ? *p : *reinterpret_cast<const ::common::UniqueId*>(
      &::common::_UniqueId_default_instance_);
}
inline ::common::UniqueId* Item::release_id() {
  // @@protoc_insertion_point(field_release:container.Item.id)
  
  ::common::UniqueId* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::common::UniqueId* Item::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::common::UniqueId;
  }
  // @@protoc_insertion_point(field_mutable:container.Item.id)
  return id_;
}
inline void Item::set_allocated_id(::common::UniqueId* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:container.Item.id)
}

// string content = 2;
inline void Item::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Item::content() const {
  // @@protoc_insertion_point(field_get:container.Item.content)
  return content_.GetNoArena();
}
inline void Item::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:container.Item.content)
}
#if LANG_CXX11
inline void Item::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:container.Item.content)
}
#endif
inline void Item::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:container.Item.content)
}
inline void Item::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:container.Item.content)
}
inline ::std::string* Item::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:container.Item.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Item::release_content() {
  // @@protoc_insertion_point(field_release:container.Item.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Item::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:container.Item.content)
}

// bytes blob = 3;
inline void Item::clear_blob() {
  blob_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Item::blob() const {
  // @@protoc_insertion_point(field_get:container.Item.blob)
  return blob_.GetNoArena();
}
inline void Item::set_blob(const ::std::string& value) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:container.Item.blob)
}
#if LANG_CXX11
inline void Item::set_blob(::std::string&& value) {
  
  blob_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:container.Item.blob)
}
#endif
inline void Item::set_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:container.Item.blob)
}
inline void Item::set_blob(const void* value, size_t size) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:container.Item.blob)
}
inline ::std::string* Item::mutable_blob() {
  
  // @@protoc_insertion_point(field_mutable:container.Item.blob)
  return blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Item::release_blob() {
  // @@protoc_insertion_point(field_release:container.Item.blob)
  
  return blob_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Item::set_allocated_blob(::std::string* blob) {
  if (blob != NULL) {
    
  } else {
    
  }
  blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blob);
  // @@protoc_insertion_point(field_set_allocated:container.Item.blob)
}

// -------------------------------------------------------------------

// Items

// repeated .container.Item items = 1;
inline int Items::items_size() const {
  return items_.size();
}
inline void Items::clear_items() {
  items_.Clear();
}
inline const ::container::Item& Items::items(int index) const {
  // @@protoc_insertion_point(field_get:container.Items.items)
  return items_.Get(index);
}
inline ::container::Item* Items::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:container.Items.items)
  return items_.Mutable(index);
}
inline ::container::Item* Items::add_items() {
  // @@protoc_insertion_point(field_add:container.Items.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::container::Item >*
Items::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:container.Items.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::container::Item >&
Items::items() const {
  // @@protoc_insertion_point(field_list:container.Items.items)
  return items_;
}

// -------------------------------------------------------------------

// ItemsOfContainer

// string container_name = 1;
inline void ItemsOfContainer::clear_container_name() {
  container_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ItemsOfContainer::container_name() const {
  // @@protoc_insertion_point(field_get:container.ItemsOfContainer.container_name)
  return container_name_.GetNoArena();
}
inline void ItemsOfContainer::set_container_name(const ::std::string& value) {
  
  container_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:container.ItemsOfContainer.container_name)
}
#if LANG_CXX11
inline void ItemsOfContainer::set_container_name(::std::string&& value) {
  
  container_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:container.ItemsOfContainer.container_name)
}
#endif
inline void ItemsOfContainer::set_container_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:container.ItemsOfContainer.container_name)
}
inline void ItemsOfContainer::set_container_name(const char* value, size_t size) {
  
  container_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:container.ItemsOfContainer.container_name)
}
inline ::std::string* ItemsOfContainer::mutable_container_name() {
  
  // @@protoc_insertion_point(field_mutable:container.ItemsOfContainer.container_name)
  return container_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ItemsOfContainer::release_container_name() {
  // @@protoc_insertion_point(field_release:container.ItemsOfContainer.container_name)
  
  return container_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ItemsOfContainer::set_allocated_container_name(::std::string* container_name) {
  if (container_name != NULL) {
    
  } else {
    
  }
  container_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_name);
  // @@protoc_insertion_point(field_set_allocated:container.ItemsOfContainer.container_name)
}

// .container.Items items = 2;
inline bool ItemsOfContainer::has_items() const {
  return this != internal_default_instance() && items_ != NULL;
}
inline void ItemsOfContainer::clear_items() {
  if (GetArenaNoVirtual() == NULL && items_ != NULL) {
    delete items_;
  }
  items_ = NULL;
}
inline const ::container::Items& ItemsOfContainer::items() const {
  const ::container::Items* p = items_;
  // @@protoc_insertion_point(field_get:container.ItemsOfContainer.items)
  return p != NULL ? *p : *reinterpret_cast<const ::container::Items*>(
      &::container::_Items_default_instance_);
}
inline ::container::Items* ItemsOfContainer::release_items() {
  // @@protoc_insertion_point(field_release:container.ItemsOfContainer.items)
  
  ::container::Items* temp = items_;
  items_ = NULL;
  return temp;
}
inline ::container::Items* ItemsOfContainer::mutable_items() {
  
  if (items_ == NULL) {
    items_ = new ::container::Items;
  }
  // @@protoc_insertion_point(field_mutable:container.ItemsOfContainer.items)
  return items_;
}
inline void ItemsOfContainer::set_allocated_items(::container::Items* items) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete items_;
  }
  if (items) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      items = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, items, submessage_arena);
    }
    
  } else {
    
  }
  items_ = items;
  // @@protoc_insertion_point(field_set_allocated:container.ItemsOfContainer.items)
}

// -------------------------------------------------------------------

// DeleteItemsRequest

// string container_name = 1;
inline void DeleteItemsRequest::clear_container_name() {
  container_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteItemsRequest::container_name() const {
  // @@protoc_insertion_point(field_get:container.DeleteItemsRequest.container_name)
  return container_name_.GetNoArena();
}
inline void DeleteItemsRequest::set_container_name(const ::std::string& value) {
  
  container_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:container.DeleteItemsRequest.container_name)
}
#if LANG_CXX11
inline void DeleteItemsRequest::set_container_name(::std::string&& value) {
  
  container_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:container.DeleteItemsRequest.container_name)
}
#endif
inline void DeleteItemsRequest::set_container_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:container.DeleteItemsRequest.container_name)
}
inline void DeleteItemsRequest::set_container_name(const char* value, size_t size) {
  
  container_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:container.DeleteItemsRequest.container_name)
}
inline ::std::string* DeleteItemsRequest::mutable_container_name() {
  
  // @@protoc_insertion_point(field_mutable:container.DeleteItemsRequest.container_name)
  return container_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteItemsRequest::release_container_name() {
  // @@protoc_insertion_point(field_release:container.DeleteItemsRequest.container_name)
  
  return container_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteItemsRequest::set_allocated_container_name(::std::string* container_name) {
  if (container_name != NULL) {
    
  } else {
    
  }
  container_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_name);
  // @@protoc_insertion_point(field_set_allocated:container.DeleteItemsRequest.container_name)
}

// .common.IdSet id_set = 2;
inline bool DeleteItemsRequest::has_id_set() const {
  return this != internal_default_instance() && id_set_ != NULL;
}
inline const ::common::IdSet& DeleteItemsRequest::id_set() const {
  const ::common::IdSet* p = id_set_;
  // @@protoc_insertion_point(field_get:container.DeleteItemsRequest.id_set)
  return p != NULL ? *p : *reinterpret_cast<const ::common::IdSet*>(
      &::common::_IdSet_default_instance_);
}
inline ::common::IdSet* DeleteItemsRequest::release_id_set() {
  // @@protoc_insertion_point(field_release:container.DeleteItemsRequest.id_set)
  
  ::common::IdSet* temp = id_set_;
  id_set_ = NULL;
  return temp;
}
inline ::common::IdSet* DeleteItemsRequest::mutable_id_set() {
  
  if (id_set_ == NULL) {
    id_set_ = new ::common::IdSet;
  }
  // @@protoc_insertion_point(field_mutable:container.DeleteItemsRequest.id_set)
  return id_set_;
}
inline void DeleteItemsRequest::set_allocated_id_set(::common::IdSet* id_set) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_set_);
  }
  if (id_set) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id_set = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id_set, submessage_arena);
    }
    
  } else {
    
  }
  id_set_ = id_set;
  // @@protoc_insertion_point(field_set_allocated:container.DeleteItemsRequest.id_set)
}

// -------------------------------------------------------------------

// Backup

// bytes blob = 1;
inline void Backup::clear_blob() {
  blob_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Backup::blob() const {
  // @@protoc_insertion_point(field_get:container.Backup.blob)
  return blob_.GetNoArena();
}
inline void Backup::set_blob(const ::std::string& value) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:container.Backup.blob)
}
#if LANG_CXX11
inline void Backup::set_blob(::std::string&& value) {
  
  blob_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:container.Backup.blob)
}
#endif
inline void Backup::set_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:container.Backup.blob)
}
inline void Backup::set_blob(const void* value, size_t size) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:container.Backup.blob)
}
inline ::std::string* Backup::mutable_blob() {
  
  // @@protoc_insertion_point(field_mutable:container.Backup.blob)
  return blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Backup::release_blob() {
  // @@protoc_insertion_point(field_release:container.Backup.blob)
  
  return blob_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Backup::set_allocated_blob(::std::string* blob) {
  if (blob != NULL) {
    
  } else {
    
  }
  blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blob);
  // @@protoc_insertion_point(field_set_allocated:container.Backup.blob)
}

// -------------------------------------------------------------------

// Func

// .container.FuncType func_type = 1;
inline void Func::clear_func_type() {
  func_type_ = 0;
}
inline ::container::FuncType Func::func_type() const {
  // @@protoc_insertion_point(field_get:container.Func.func_type)
  return static_cast< ::container::FuncType >(func_type_);
}
inline void Func::set_func_type(::container::FuncType value) {
  
  func_type_ = value;
  // @@protoc_insertion_point(field_set:container.Func.func_type)
}

// string container_name = 2;
inline void Func::clear_container_name() {
  container_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Func::container_name() const {
  // @@protoc_insertion_point(field_get:container.Func.container_name)
  return container_name_.GetNoArena();
}
inline void Func::set_container_name(const ::std::string& value) {
  
  container_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:container.Func.container_name)
}
#if LANG_CXX11
inline void Func::set_container_name(::std::string&& value) {
  
  container_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:container.Func.container_name)
}
#endif
inline void Func::set_container_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:container.Func.container_name)
}
inline void Func::set_container_name(const char* value, size_t size) {
  
  container_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:container.Func.container_name)
}
inline ::std::string* Func::mutable_container_name() {
  
  // @@protoc_insertion_point(field_mutable:container.Func.container_name)
  return container_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Func::release_container_name() {
  // @@protoc_insertion_point(field_release:container.Func.container_name)
  
  return container_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Func::set_allocated_container_name(::std::string* container_name) {
  if (container_name != NULL) {
    
  } else {
    
  }
  container_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_name);
  // @@protoc_insertion_point(field_set_allocated:container.Func.container_name)
}

// -------------------------------------------------------------------

// FuncResult

// .common.OperationResultMessage op_result = 1;
inline bool FuncResult::has_op_result() const {
  return this != internal_default_instance() && op_result_ != NULL;
}
inline const ::common::OperationResultMessage& FuncResult::op_result() const {
  const ::common::OperationResultMessage* p = op_result_;
  // @@protoc_insertion_point(field_get:container.FuncResult.op_result)
  return p != NULL ? *p : *reinterpret_cast<const ::common::OperationResultMessage*>(
      &::common::_OperationResultMessage_default_instance_);
}
inline ::common::OperationResultMessage* FuncResult::release_op_result() {
  // @@protoc_insertion_point(field_release:container.FuncResult.op_result)
  
  ::common::OperationResultMessage* temp = op_result_;
  op_result_ = NULL;
  return temp;
}
inline ::common::OperationResultMessage* FuncResult::mutable_op_result() {
  
  if (op_result_ == NULL) {
    op_result_ = new ::common::OperationResultMessage;
  }
  // @@protoc_insertion_point(field_mutable:container.FuncResult.op_result)
  return op_result_;
}
inline void FuncResult::set_allocated_op_result(::common::OperationResultMessage* op_result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(op_result_);
  }
  if (op_result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      op_result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, op_result, submessage_arena);
    }
    
  } else {
    
  }
  op_result_ = op_result;
  // @@protoc_insertion_point(field_set_allocated:container.FuncResult.op_result)
}

// double value = 2;
inline void FuncResult::clear_value() {
  value_ = 0;
}
inline double FuncResult::value() const {
  // @@protoc_insertion_point(field_get:container.FuncResult.value)
  return value_;
}
inline void FuncResult::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:container.FuncResult.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace container

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::container::FuncType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::container::FuncType>() {
  return ::container::FuncType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_container_2eproto__INCLUDED
