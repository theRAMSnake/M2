// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: calendar.proto

#ifndef PROTOBUF_calendar_2eproto__INCLUDED
#define PROTOBUF_calendar_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_calendar_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsCalendarItemImpl();
void InitDefaultsCalendarItem();
void InitDefaultsCalendarItemsImpl();
void InitDefaultsCalendarItems();
void InitDefaultsTimeRangeImpl();
void InitDefaultsTimeRange();
void InitDefaultsNextQueryParametersImpl();
void InitDefaultsNextQueryParameters();
inline void InitDefaults() {
  InitDefaultsCalendarItem();
  InitDefaultsCalendarItems();
  InitDefaultsTimeRange();
  InitDefaultsNextQueryParameters();
}
}  // namespace protobuf_calendar_2eproto
namespace calendar {
class CalendarItem;
class CalendarItemDefaultTypeInternal;
extern CalendarItemDefaultTypeInternal _CalendarItem_default_instance_;
class CalendarItems;
class CalendarItemsDefaultTypeInternal;
extern CalendarItemsDefaultTypeInternal _CalendarItems_default_instance_;
class NextQueryParameters;
class NextQueryParametersDefaultTypeInternal;
extern NextQueryParametersDefaultTypeInternal _NextQueryParameters_default_instance_;
class TimeRange;
class TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
}  // namespace calendar
namespace calendar {

// ===================================================================

class CalendarItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calendar.CalendarItem) */ {
 public:
  CalendarItem();
  virtual ~CalendarItem();

  CalendarItem(const CalendarItem& from);

  inline CalendarItem& operator=(const CalendarItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CalendarItem(CalendarItem&& from) noexcept
    : CalendarItem() {
    *this = ::std::move(from);
  }

  inline CalendarItem& operator=(CalendarItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CalendarItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalendarItem* internal_default_instance() {
    return reinterpret_cast<const CalendarItem*>(
               &_CalendarItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CalendarItem* other);
  friend void swap(CalendarItem& a, CalendarItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalendarItem* New() const PROTOBUF_FINAL { return New(NULL); }

  CalendarItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CalendarItem& from);
  void MergeFrom(const CalendarItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CalendarItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // .common.UniqueId id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::common::UniqueId& id() const;
  ::common::UniqueId* release_id();
  ::common::UniqueId* mutable_id();
  void set_allocated_id(::common::UniqueId* id);

  // int64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:calendar.CalendarItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::common::UniqueId* id_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_calendar_2eproto::TableStruct;
  friend void ::protobuf_calendar_2eproto::InitDefaultsCalendarItemImpl();
};
// -------------------------------------------------------------------

class CalendarItems : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calendar.CalendarItems) */ {
 public:
  CalendarItems();
  virtual ~CalendarItems();

  CalendarItems(const CalendarItems& from);

  inline CalendarItems& operator=(const CalendarItems& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CalendarItems(CalendarItems&& from) noexcept
    : CalendarItems() {
    *this = ::std::move(from);
  }

  inline CalendarItems& operator=(CalendarItems&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CalendarItems& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalendarItems* internal_default_instance() {
    return reinterpret_cast<const CalendarItems*>(
               &_CalendarItems_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CalendarItems* other);
  friend void swap(CalendarItems& a, CalendarItems& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalendarItems* New() const PROTOBUF_FINAL { return New(NULL); }

  CalendarItems* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CalendarItems& from);
  void MergeFrom(const CalendarItems& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CalendarItems* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calendar.CalendarItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::calendar::CalendarItem& items(int index) const;
  ::calendar::CalendarItem* mutable_items(int index);
  ::calendar::CalendarItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::calendar::CalendarItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::calendar::CalendarItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:calendar.CalendarItems)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calendar::CalendarItem > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_calendar_2eproto::TableStruct;
  friend void ::protobuf_calendar_2eproto::InitDefaultsCalendarItemsImpl();
};
// -------------------------------------------------------------------

class TimeRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calendar.TimeRange) */ {
 public:
  TimeRange();
  virtual ~TimeRange();

  TimeRange(const TimeRange& from);

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TimeRange* other);
  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeRange* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeRange& from);
  void MergeFrom(const TimeRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 timestampFrom = 1;
  void clear_timestampfrom();
  static const int kTimestampFromFieldNumber = 1;
  ::google::protobuf::int64 timestampfrom() const;
  void set_timestampfrom(::google::protobuf::int64 value);

  // int64 timestampTo = 2;
  void clear_timestampto();
  static const int kTimestampToFieldNumber = 2;
  ::google::protobuf::int64 timestampto() const;
  void set_timestampto(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:calendar.TimeRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 timestampfrom_;
  ::google::protobuf::int64 timestampto_;
  mutable int _cached_size_;
  friend struct ::protobuf_calendar_2eproto::TableStruct;
  friend void ::protobuf_calendar_2eproto::InitDefaultsTimeRangeImpl();
};
// -------------------------------------------------------------------

class NextQueryParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calendar.NextQueryParameters) */ {
 public:
  NextQueryParameters();
  virtual ~NextQueryParameters();

  NextQueryParameters(const NextQueryParameters& from);

  inline NextQueryParameters& operator=(const NextQueryParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NextQueryParameters(NextQueryParameters&& from) noexcept
    : NextQueryParameters() {
    *this = ::std::move(from);
  }

  inline NextQueryParameters& operator=(NextQueryParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NextQueryParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NextQueryParameters* internal_default_instance() {
    return reinterpret_cast<const NextQueryParameters*>(
               &_NextQueryParameters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NextQueryParameters* other);
  friend void swap(NextQueryParameters& a, NextQueryParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NextQueryParameters* New() const PROTOBUF_FINAL { return New(NULL); }

  NextQueryParameters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NextQueryParameters& from);
  void MergeFrom(const NextQueryParameters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NextQueryParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 timestampFrom = 1;
  void clear_timestampfrom();
  static const int kTimestampFromFieldNumber = 1;
  ::google::protobuf::int64 timestampfrom() const;
  void set_timestampfrom(::google::protobuf::int64 value);

  // int32 limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  ::google::protobuf::int32 limit() const;
  void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:calendar.NextQueryParameters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 timestampfrom_;
  ::google::protobuf::int32 limit_;
  mutable int _cached_size_;
  friend struct ::protobuf_calendar_2eproto::TableStruct;
  friend void ::protobuf_calendar_2eproto::InitDefaultsNextQueryParametersImpl();
};
// ===================================================================

class CalendarService_Stub;

class CalendarService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline CalendarService() {};
 public:
  virtual ~CalendarService();

  typedef CalendarService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void Query(::google::protobuf::RpcController* controller,
                       const ::calendar::TimeRange* request,
                       ::calendar::CalendarItems* response,
                       ::google::protobuf::Closure* done);
  virtual void Next(::google::protobuf::RpcController* controller,
                       const ::calendar::NextQueryParameters* request,
                       ::calendar::CalendarItems* response,
                       ::google::protobuf::Closure* done);
  virtual void DeleteItem(::google::protobuf::RpcController* controller,
                       const ::common::UniqueId* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void EditItem(::google::protobuf::RpcController* controller,
                       const ::calendar::CalendarItem* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void AddItem(::google::protobuf::RpcController* controller,
                       const ::calendar::CalendarItem* request,
                       ::common::UniqueId* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CalendarService);
};

class CalendarService_Stub : public CalendarService {
 public:
  CalendarService_Stub(::google::protobuf::RpcChannel* channel);
  CalendarService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~CalendarService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements CalendarService ------------------------------------------

  void Query(::google::protobuf::RpcController* controller,
                       const ::calendar::TimeRange* request,
                       ::calendar::CalendarItems* response,
                       ::google::protobuf::Closure* done);
  void Next(::google::protobuf::RpcController* controller,
                       const ::calendar::NextQueryParameters* request,
                       ::calendar::CalendarItems* response,
                       ::google::protobuf::Closure* done);
  void DeleteItem(::google::protobuf::RpcController* controller,
                       const ::common::UniqueId* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  void EditItem(::google::protobuf::RpcController* controller,
                       const ::calendar::CalendarItem* request,
                       ::common::OperationResultMessage* response,
                       ::google::protobuf::Closure* done);
  void AddItem(::google::protobuf::RpcController* controller,
                       const ::calendar::CalendarItem* request,
                       ::common::UniqueId* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CalendarService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CalendarItem

// .common.UniqueId id = 1;
inline bool CalendarItem::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline const ::common::UniqueId& CalendarItem::id() const {
  const ::common::UniqueId* p = id_;
  // @@protoc_insertion_point(field_get:calendar.CalendarItem.id)
  return p != NULL ? *p : *reinterpret_cast<const ::common::UniqueId*>(
      &::common::_UniqueId_default_instance_);
}
inline ::common::UniqueId* CalendarItem::release_id() {
  // @@protoc_insertion_point(field_release:calendar.CalendarItem.id)
  
  ::common::UniqueId* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::common::UniqueId* CalendarItem::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::common::UniqueId;
  }
  // @@protoc_insertion_point(field_mutable:calendar.CalendarItem.id)
  return id_;
}
inline void CalendarItem::set_allocated_id(::common::UniqueId* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:calendar.CalendarItem.id)
}

// string text = 2;
inline void CalendarItem::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CalendarItem::text() const {
  // @@protoc_insertion_point(field_get:calendar.CalendarItem.text)
  return text_.GetNoArena();
}
inline void CalendarItem::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calendar.CalendarItem.text)
}
#if LANG_CXX11
inline void CalendarItem::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calendar.CalendarItem.text)
}
#endif
inline void CalendarItem::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calendar.CalendarItem.text)
}
inline void CalendarItem::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calendar.CalendarItem.text)
}
inline ::std::string* CalendarItem::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:calendar.CalendarItem.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CalendarItem::release_text() {
  // @@protoc_insertion_point(field_release:calendar.CalendarItem.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CalendarItem::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:calendar.CalendarItem.text)
}

// int64 timestamp = 3;
inline void CalendarItem::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CalendarItem::timestamp() const {
  // @@protoc_insertion_point(field_get:calendar.CalendarItem.timestamp)
  return timestamp_;
}
inline void CalendarItem::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calendar.CalendarItem.timestamp)
}

// -------------------------------------------------------------------

// CalendarItems

// repeated .calendar.CalendarItem items = 1;
inline int CalendarItems::items_size() const {
  return items_.size();
}
inline void CalendarItems::clear_items() {
  items_.Clear();
}
inline const ::calendar::CalendarItem& CalendarItems::items(int index) const {
  // @@protoc_insertion_point(field_get:calendar.CalendarItems.items)
  return items_.Get(index);
}
inline ::calendar::CalendarItem* CalendarItems::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:calendar.CalendarItems.items)
  return items_.Mutable(index);
}
inline ::calendar::CalendarItem* CalendarItems::add_items() {
  // @@protoc_insertion_point(field_add:calendar.CalendarItems.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calendar::CalendarItem >*
CalendarItems::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:calendar.CalendarItems.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calendar::CalendarItem >&
CalendarItems::items() const {
  // @@protoc_insertion_point(field_list:calendar.CalendarItems.items)
  return items_;
}

// -------------------------------------------------------------------

// TimeRange

// int64 timestampFrom = 1;
inline void TimeRange::clear_timestampfrom() {
  timestampfrom_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TimeRange::timestampfrom() const {
  // @@protoc_insertion_point(field_get:calendar.TimeRange.timestampFrom)
  return timestampfrom_;
}
inline void TimeRange::set_timestampfrom(::google::protobuf::int64 value) {
  
  timestampfrom_ = value;
  // @@protoc_insertion_point(field_set:calendar.TimeRange.timestampFrom)
}

// int64 timestampTo = 2;
inline void TimeRange::clear_timestampto() {
  timestampto_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TimeRange::timestampto() const {
  // @@protoc_insertion_point(field_get:calendar.TimeRange.timestampTo)
  return timestampto_;
}
inline void TimeRange::set_timestampto(::google::protobuf::int64 value) {
  
  timestampto_ = value;
  // @@protoc_insertion_point(field_set:calendar.TimeRange.timestampTo)
}

// -------------------------------------------------------------------

// NextQueryParameters

// int64 timestampFrom = 1;
inline void NextQueryParameters::clear_timestampfrom() {
  timestampfrom_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NextQueryParameters::timestampfrom() const {
  // @@protoc_insertion_point(field_get:calendar.NextQueryParameters.timestampFrom)
  return timestampfrom_;
}
inline void NextQueryParameters::set_timestampfrom(::google::protobuf::int64 value) {
  
  timestampfrom_ = value;
  // @@protoc_insertion_point(field_set:calendar.NextQueryParameters.timestampFrom)
}

// int32 limit = 2;
inline void NextQueryParameters::clear_limit() {
  limit_ = 0;
}
inline ::google::protobuf::int32 NextQueryParameters::limit() const {
  // @@protoc_insertion_point(field_get:calendar.NextQueryParameters.limit)
  return limit_;
}
inline void NextQueryParameters::set_limit(::google::protobuf::int32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:calendar.NextQueryParameters.limit)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace calendar

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_calendar_2eproto__INCLUDED
